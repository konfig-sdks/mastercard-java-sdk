/*
 * Open Banking
 * OpenAPI specification for Finicity APIs.  Open Banking solutions in the US are provided by Finicity, a Mastercard company.
 *
 * The version of the OpenAPI document: 1.16.0
 * Contact: apisupport@mastercard.com
 *
 * NOTE: This class is auto generated by Konfig (https://konfigthis.com).
 * Do not edit the class manually.
 */


package com.konfigthis.client.api;

import com.konfigthis.client.ApiCallback;
import com.konfigthis.client.ApiClient;
import com.konfigthis.client.ApiException;
import com.konfigthis.client.ApiResponse;
import com.konfigthis.client.Configuration;
import com.konfigthis.client.Pair;
import com.konfigthis.client.ProgressRequestBody;
import com.konfigthis.client.ProgressResponseBody;

import com.google.gson.reflect.TypeToken;

import java.io.IOException;


import com.konfigthis.client.model.ReportCustomField;
import com.konfigthis.client.model.Transaction;
import com.konfigthis.client.model.Transactions;
import com.konfigthis.client.model.TransactionsReportAck;
import com.konfigthis.client.model.TransactionsReportConstraints;

import java.lang.reflect.Type;
import java.util.ArrayList;
import java.util.HashMap;
import java.util.List;
import java.util.Map;
import javax.ws.rs.core.GenericType;

public class TransactionsApiGenerated {
    private ApiClient localVarApiClient;
    private int localHostIndex;
    private String localCustomBaseUrl;

    public TransactionsApiGenerated() throws IllegalArgumentException {
        this(Configuration.getDefaultApiClient());
    }

    public TransactionsApiGenerated(ApiClient apiClient) throws IllegalArgumentException {
        if (apiClient.getFinicityAppKey() == null) {
            throw new IllegalArgumentException("\"Finicity-App-Key\" is required but no API key was provided. Please set \"Finicity-App-Key\" with ApiClient#setFinicityAppKey(String).");
        }
        if (apiClient.getFinicityAppToken() == null) {
            throw new IllegalArgumentException("\"Finicity-App-Token\" is required but no API key was provided. Please set \"Finicity-App-Token\" with ApiClient#setFinicityAppToken(String).");
        }
        this.localVarApiClient = apiClient;
    }

    public ApiClient getApiClient() {
        return localVarApiClient;
    }

    public void setApiClient(ApiClient apiClient) {
        this.localVarApiClient = apiClient;
    }

    public int getHostIndex() {
        return localHostIndex;
    }

    public void setHostIndex(int hostIndex) {
        this.localHostIndex = hostIndex;
    }

    public String getCustomBaseUrl() {
        return localCustomBaseUrl;
    }

    public void setCustomBaseUrl(String customBaseUrl) {
        this.localCustomBaseUrl = customBaseUrl;
    }

    private okhttp3.Call get24MonthsHistoryAndGenerateReportCall(String customerId, Long toDate, TransactionsReportConstraints transactionsReportConstraints, String callbackUrl, Boolean includePending, final ApiCallback _callback) throws ApiException {
        String basePath = null;
        // Operation Servers
        String[] localBasePaths = new String[] {  };

        // Determine Base Path to Use
        if (localCustomBaseUrl != null){
            basePath = localCustomBaseUrl;
        } else if ( localBasePaths.length > 0 ) {
            basePath = localBasePaths[localHostIndex];
        } else {
            basePath = null;
        }

        Object localVarPostBody = transactionsReportConstraints;

        // create path and map variables
        String localVarPath = "/decisioning/v2/customers/{customerId}/transactions"
            .replace("{" + "customerId" + "}", localVarApiClient.escapeString(customerId.toString()));

        List<Pair> localVarQueryParams = new ArrayList<Pair>();
        List<Pair> localVarCollectionQueryParams = new ArrayList<Pair>();
        Map<String, String> localVarHeaderParams = new HashMap<String, String>();
        Map<String, String> localVarCookieParams = new HashMap<String, String>();
        Map<String, Object> localVarFormParams = new HashMap<String, Object>();

        if (callbackUrl != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("callbackUrl", callbackUrl));
        }

        if (toDate != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("toDate", toDate));
        }

        if (includePending != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("includePending", includePending));
        }

        final String[] localVarAccepts = {
            "application/json"
        };
        final String localVarAccept = localVarApiClient.selectHeaderAccept(localVarAccepts);
        if (localVarAccept != null) {
            localVarHeaderParams.put("Accept", localVarAccept);
        }

        final String[] localVarContentTypes = {
            "application/json"
        };
        final String localVarContentType = localVarApiClient.selectHeaderContentType(localVarContentTypes);
        if (localVarContentType != null) {
            localVarHeaderParams.put("Content-Type", localVarContentType);
        }

        String[] localVarAuthNames = new String[] { "FinicityAppKey", "FinicityAppToken" };
        return localVarApiClient.buildCall(basePath, localVarPath, "POST", localVarQueryParams, localVarCollectionQueryParams, localVarPostBody, localVarHeaderParams, localVarCookieParams, localVarFormParams, localVarAuthNames, _callback);
    }

    @SuppressWarnings("rawtypes")
    private okhttp3.Call get24MonthsHistoryAndGenerateReportValidateBeforeCall(String customerId, Long toDate, TransactionsReportConstraints transactionsReportConstraints, String callbackUrl, Boolean includePending, final ApiCallback _callback) throws ApiException {
        // verify the required parameter 'customerId' is set
        if (customerId == null) {
            throw new ApiException("Missing the required parameter 'customerId' when calling get24MonthsHistoryAndGenerateReport(Async)");
        }

        // verify the required parameter 'toDate' is set
        if (toDate == null) {
            throw new ApiException("Missing the required parameter 'toDate' when calling get24MonthsHistoryAndGenerateReport(Async)");
        }

        // verify the required parameter 'transactionsReportConstraints' is set
        if (transactionsReportConstraints == null) {
            throw new ApiException("Missing the required parameter 'transactionsReportConstraints' when calling get24MonthsHistoryAndGenerateReport(Async)");
        }

        return get24MonthsHistoryAndGenerateReportCall(customerId, toDate, transactionsReportConstraints, callbackUrl, includePending, _callback);

    }


    private ApiResponse<TransactionsReportAck> get24MonthsHistoryAndGenerateReportWithHttpInfo(String customerId, Long toDate, TransactionsReportConstraints transactionsReportConstraints, String callbackUrl, Boolean includePending) throws ApiException {
        okhttp3.Call localVarCall = get24MonthsHistoryAndGenerateReportValidateBeforeCall(customerId, toDate, transactionsReportConstraints, callbackUrl, includePending, null);
        Type localVarReturnType = new TypeToken<TransactionsReportAck>(){}.getType();
        return localVarApiClient.execute(localVarCall, localVarReturnType);
    }

    private okhttp3.Call get24MonthsHistoryAndGenerateReportAsync(String customerId, Long toDate, TransactionsReportConstraints transactionsReportConstraints, String callbackUrl, Boolean includePending, final ApiCallback<TransactionsReportAck> _callback) throws ApiException {

        okhttp3.Call localVarCall = get24MonthsHistoryAndGenerateReportValidateBeforeCall(customerId, toDate, transactionsReportConstraints, callbackUrl, includePending, _callback);
        Type localVarReturnType = new TypeToken<TransactionsReportAck>(){}.getType();
        localVarApiClient.executeAsync(localVarCall, localVarReturnType, _callback);
        return localVarCall;
    }

    public class Get24MonthsHistoryAndGenerateReportRequestBuilder {
        private final String customerId;
        private final Long toDate;
        private String accountIds;
        private Long fromDate;
        private List<ReportCustomField> reportCustomFields;
        private String callbackUrl;
        private Boolean includePending;

        private Get24MonthsHistoryAndGenerateReportRequestBuilder(String customerId, Long toDate) {
            this.customerId = customerId;
            this.toDate = toDate;
        }

        /**
         * Set accountIds
         * @param accountIds A whitespace-separated list of account IDs to be included in the report (all accounts will be included if not set) (optional)
         * @return Get24MonthsHistoryAndGenerateReportRequestBuilder
         */
        public Get24MonthsHistoryAndGenerateReportRequestBuilder accountIds(String accountIds) {
            this.accountIds = accountIds;
            return this;
        }
        
        /**
         * Set fromDate
         * @param fromDate A date in Unix epoch time (in seconds). See: [Handling Epoch Dates and Times](https://developer.mastercard.com/open-banking-us/documentation/codes-and-formats/). (optional)
         * @return Get24MonthsHistoryAndGenerateReportRequestBuilder
         */
        public Get24MonthsHistoryAndGenerateReportRequestBuilder fromDate(Long fromDate) {
            this.fromDate = fromDate;
            return this;
        }
        
        /**
         * Set reportCustomFields
         * @param reportCustomFields The &#x60;reportCustomFields&#x60; parameter is used when experiences are associated with a credit decisioning report.  Designate up to 5 custom fields that you&#39;d like associated with the report when it&#39;s generated. Every custom field consists of three variables: &#x60;label&#x60;, &#x60;value&#x60;, and &#x60;shown&#x60;. The &#x60;shown&#x60; variable is \\\&quot;true\\\&quot; or \\\&quot;false\\\&quot;. * \\\&quot;true\\\&quot;: (default) display the custom field in the PDF report * \\\&quot;false\\\&quot;: don&#39;t display the custom field in the PDF report  For an experience that generates multiple reports, the &#x60;reportCustomFields&#x60; parameter gets passed to all reports.  All custom fields display in the Reseller Billing API. (optional)
         * @return Get24MonthsHistoryAndGenerateReportRequestBuilder
         */
        public Get24MonthsHistoryAndGenerateReportRequestBuilder reportCustomFields(List<ReportCustomField> reportCustomFields) {
            this.reportCustomFields = reportCustomFields;
            return this;
        }
        
        /**
         * Set callbackUrl
         * @param callbackUrl A Report Listener URL to receive notifications. The webhook must respond to the Finicity API with a 2xx HTTP status code. (optional)
         * @return Get24MonthsHistoryAndGenerateReportRequestBuilder
         */
        public Get24MonthsHistoryAndGenerateReportRequestBuilder callbackUrl(String callbackUrl) {
            this.callbackUrl = callbackUrl;
            return this;
        }
        
        /**
         * Set includePending
         * @param includePending If pending transactions must be included (optional, default to false)
         * @return Get24MonthsHistoryAndGenerateReportRequestBuilder
         */
        public Get24MonthsHistoryAndGenerateReportRequestBuilder includePending(Boolean includePending) {
            this.includePending = includePending;
            return this;
        }
        
        /**
         * Build call for get24MonthsHistoryAndGenerateReport
         * @param _callback ApiCallback API callback
         * @return Call to execute
         * @throws ApiException If fail to serialize the request body object
         * @http.response.details
         <table summary="Response Details" border="1">
            <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
            <tr><td> 202 </td><td> The report is being generated. When finished, a notification will be sent to the specified callback URL (Report Listener Service) and the report can be fetched using Get Report APIs. If you don&#39;t use a callback URL, Get Report returns a minimal report with the following status: &#39;inProgress&#39;. Repeat the call every 20 seconds until Get Report returns a different status. </td><td>  -  </td></tr>
         </table>
         */
        public okhttp3.Call buildCall(final ApiCallback _callback) throws ApiException {
            TransactionsReportConstraints transactionsReportConstraints = buildBodyParams();
            return get24MonthsHistoryAndGenerateReportCall(customerId, toDate, transactionsReportConstraints, callbackUrl, includePending, _callback);
        }

        private TransactionsReportConstraints buildBodyParams() {
            TransactionsReportConstraints transactionsReportConstraints = new TransactionsReportConstraints();
            transactionsReportConstraints.accountIds(this.accountIds);
            transactionsReportConstraints.fromDate(this.fromDate);
            transactionsReportConstraints.reportCustomFields(this.reportCustomFields);
            return transactionsReportConstraints;
        }

        /**
         * Execute get24MonthsHistoryAndGenerateReport request
         * @return TransactionsReportAck
         * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
         * @http.response.details
         <table summary="Response Details" border="1">
            <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
            <tr><td> 202 </td><td> The report is being generated. When finished, a notification will be sent to the specified callback URL (Report Listener Service) and the report can be fetched using Get Report APIs. If you don&#39;t use a callback URL, Get Report returns a minimal report with the following status: &#39;inProgress&#39;. Repeat the call every 20 seconds until Get Report returns a different status. </td><td>  -  </td></tr>
         </table>
         */
        public TransactionsReportAck execute() throws ApiException {
            TransactionsReportConstraints transactionsReportConstraints = buildBodyParams();
            ApiResponse<TransactionsReportAck> localVarResp = get24MonthsHistoryAndGenerateReportWithHttpInfo(customerId, toDate, transactionsReportConstraints, callbackUrl, includePending);
            return localVarResp.getResponseBody();
        }

        /**
         * Execute get24MonthsHistoryAndGenerateReport request with HTTP info returned
         * @return ApiResponse&lt;TransactionsReportAck&gt;
         * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
         * @http.response.details
         <table summary="Response Details" border="1">
            <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
            <tr><td> 202 </td><td> The report is being generated. When finished, a notification will be sent to the specified callback URL (Report Listener Service) and the report can be fetched using Get Report APIs. If you don&#39;t use a callback URL, Get Report returns a minimal report with the following status: &#39;inProgress&#39;. Repeat the call every 20 seconds until Get Report returns a different status. </td><td>  -  </td></tr>
         </table>
         */
        public ApiResponse<TransactionsReportAck> executeWithHttpInfo() throws ApiException {
            TransactionsReportConstraints transactionsReportConstraints = buildBodyParams();
            return get24MonthsHistoryAndGenerateReportWithHttpInfo(customerId, toDate, transactionsReportConstraints, callbackUrl, includePending);
        }

        /**
         * Execute get24MonthsHistoryAndGenerateReport request (asynchronously)
         * @param _callback The callback to be executed when the API call finishes
         * @return The request call
         * @throws ApiException If fail to process the API call, e.g. serializing the request body object
         * @http.response.details
         <table summary="Response Details" border="1">
            <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
            <tr><td> 202 </td><td> The report is being generated. When finished, a notification will be sent to the specified callback URL (Report Listener Service) and the report can be fetched using Get Report APIs. If you don&#39;t use a callback URL, Get Report returns a minimal report with the following status: &#39;inProgress&#39;. Repeat the call every 20 seconds until Get Report returns a different status. </td><td>  -  </td></tr>
         </table>
         */
        public okhttp3.Call executeAsync(final ApiCallback<TransactionsReportAck> _callback) throws ApiException {
            TransactionsReportConstraints transactionsReportConstraints = buildBodyParams();
            return get24MonthsHistoryAndGenerateReportAsync(customerId, toDate, transactionsReportConstraints, callbackUrl, includePending, _callback);
        }
    }

    /**
     * Generate Transactions Report
     * Generate a Transaction Report for the given accounts under the given customer. This service retrieves up to 24 months of transaction history for the given customer. It then uses this information to generate the Transaction Report.  This is a premium service. A billable event will be created upon the successful generation of the Transactions Report.  Before calling this API, a consumer must be created for the given customer ID (see Consumers APIs).  There cannot be more than 24 months between &#x60;fromDate&#x60; and &#x60;toDate&#x60;.  _Supported regions_: ![🇺🇸](https://flagcdn.com/20x15/us.png)
     * @param customerId A customer ID (required)
     * @param toDate A end date (required)
     * @param transactionsReportConstraints  (required)
     * @return Get24MonthsHistoryAndGenerateReportRequestBuilder
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 202 </td><td> The report is being generated. When finished, a notification will be sent to the specified callback URL (Report Listener Service) and the report can be fetched using Get Report APIs. If you don&#39;t use a callback URL, Get Report returns a minimal report with the following status: &#39;inProgress&#39;. Repeat the call every 20 seconds until Get Report returns a different status. </td><td>  -  </td></tr>
     </table>
     */
    public Get24MonthsHistoryAndGenerateReportRequestBuilder get24MonthsHistoryAndGenerateReport(String customerId, Long toDate) throws IllegalArgumentException {
        if (customerId == null) throw new IllegalArgumentException("\"customerId\" is required but got null");
            

        if (toDate == null) throw new IllegalArgumentException("\"toDate\" is required but got null");
        return new Get24MonthsHistoryAndGenerateReportRequestBuilder(customerId, toDate);
    }
    private okhttp3.Call getAllCustomerTransactionsCall(String customerId, Long fromDate, Long toDate, Integer start, Integer limit, String sort, Boolean includePending, final ApiCallback _callback) throws ApiException {
        String basePath = null;
        // Operation Servers
        String[] localBasePaths = new String[] {  };

        // Determine Base Path to Use
        if (localCustomBaseUrl != null){
            basePath = localCustomBaseUrl;
        } else if ( localBasePaths.length > 0 ) {
            basePath = localBasePaths[localHostIndex];
        } else {
            basePath = null;
        }

        Object localVarPostBody = null;

        // create path and map variables
        String localVarPath = "/aggregation/v3/customers/{customerId}/transactions"
            .replace("{" + "customerId" + "}", localVarApiClient.escapeString(customerId.toString()));

        List<Pair> localVarQueryParams = new ArrayList<Pair>();
        List<Pair> localVarCollectionQueryParams = new ArrayList<Pair>();
        Map<String, String> localVarHeaderParams = new HashMap<String, String>();
        Map<String, String> localVarCookieParams = new HashMap<String, String>();
        Map<String, Object> localVarFormParams = new HashMap<String, Object>();

        if (fromDate != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("fromDate", fromDate));
        }

        if (toDate != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("toDate", toDate));
        }

        if (start != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("start", start));
        }

        if (limit != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("limit", limit));
        }

        if (sort != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("sort", sort));
        }

        if (includePending != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("includePending", includePending));
        }

        final String[] localVarAccepts = {
            "application/json"
        };
        final String localVarAccept = localVarApiClient.selectHeaderAccept(localVarAccepts);
        if (localVarAccept != null) {
            localVarHeaderParams.put("Accept", localVarAccept);
        }

        final String[] localVarContentTypes = {
        };
        final String localVarContentType = localVarApiClient.selectHeaderContentType(localVarContentTypes);
        if (localVarContentType != null) {
            localVarHeaderParams.put("Content-Type", localVarContentType);
        }

        String[] localVarAuthNames = new String[] { "FinicityAppKey", "FinicityAppToken" };
        return localVarApiClient.buildCall(basePath, localVarPath, "GET", localVarQueryParams, localVarCollectionQueryParams, localVarPostBody, localVarHeaderParams, localVarCookieParams, localVarFormParams, localVarAuthNames, _callback);
    }

    @SuppressWarnings("rawtypes")
    private okhttp3.Call getAllCustomerTransactionsValidateBeforeCall(String customerId, Long fromDate, Long toDate, Integer start, Integer limit, String sort, Boolean includePending, final ApiCallback _callback) throws ApiException {
        // verify the required parameter 'customerId' is set
        if (customerId == null) {
            throw new ApiException("Missing the required parameter 'customerId' when calling getAllCustomerTransactions(Async)");
        }

        // verify the required parameter 'fromDate' is set
        if (fromDate == null) {
            throw new ApiException("Missing the required parameter 'fromDate' when calling getAllCustomerTransactions(Async)");
        }

        // verify the required parameter 'toDate' is set
        if (toDate == null) {
            throw new ApiException("Missing the required parameter 'toDate' when calling getAllCustomerTransactions(Async)");
        }

        return getAllCustomerTransactionsCall(customerId, fromDate, toDate, start, limit, sort, includePending, _callback);

    }


    private ApiResponse<Transactions> getAllCustomerTransactionsWithHttpInfo(String customerId, Long fromDate, Long toDate, Integer start, Integer limit, String sort, Boolean includePending) throws ApiException {
        okhttp3.Call localVarCall = getAllCustomerTransactionsValidateBeforeCall(customerId, fromDate, toDate, start, limit, sort, includePending, null);
        Type localVarReturnType = new TypeToken<Transactions>(){}.getType();
        return localVarApiClient.execute(localVarCall, localVarReturnType);
    }

    private okhttp3.Call getAllCustomerTransactionsAsync(String customerId, Long fromDate, Long toDate, Integer start, Integer limit, String sort, Boolean includePending, final ApiCallback<Transactions> _callback) throws ApiException {

        okhttp3.Call localVarCall = getAllCustomerTransactionsValidateBeforeCall(customerId, fromDate, toDate, start, limit, sort, includePending, _callback);
        Type localVarReturnType = new TypeToken<Transactions>(){}.getType();
        localVarApiClient.executeAsync(localVarCall, localVarReturnType, _callback);
        return localVarCall;
    }

    public class GetAllCustomerTransactionsRequestBuilder {
        private final String customerId;
        private final Long fromDate;
        private final Long toDate;
        private Integer start;
        private Integer limit;
        private String sort;
        private Boolean includePending;

        private GetAllCustomerTransactionsRequestBuilder(String customerId, Long fromDate, Long toDate) {
            this.customerId = customerId;
            this.fromDate = fromDate;
            this.toDate = toDate;
        }

        /**
         * Set start
         * @param start Index of the page of results to return (optional, default to 1)
         * @return GetAllCustomerTransactionsRequestBuilder
         */
        public GetAllCustomerTransactionsRequestBuilder start(Integer start) {
            this.start = start;
            return this;
        }
        
        /**
         * Set limit
         * @param limit Maximum number of results per page (optional, default to 25)
         * @return GetAllCustomerTransactionsRequestBuilder
         */
        public GetAllCustomerTransactionsRequestBuilder limit(Integer limit) {
            this.limit = limit;
            return this;
        }
        
        /**
         * Set sort
         * @param sort Date sort order: \&quot;asc\&quot; for ascending, \&quot;desc\&quot; for descending (optional, default to desc)
         * @return GetAllCustomerTransactionsRequestBuilder
         */
        public GetAllCustomerTransactionsRequestBuilder sort(String sort) {
            this.sort = sort;
            return this;
        }
        
        /**
         * Set includePending
         * @param includePending If pending transactions must be included (optional, default to false)
         * @return GetAllCustomerTransactionsRequestBuilder
         */
        public GetAllCustomerTransactionsRequestBuilder includePending(Boolean includePending) {
            this.includePending = includePending;
            return this;
        }
        
        /**
         * Build call for getAllCustomerTransactions
         * @param _callback ApiCallback API callback
         * @return Call to execute
         * @throws ApiException If fail to serialize the request body object
         * @http.response.details
         <table summary="Response Details" border="1">
            <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
            <tr><td> 200 </td><td> The transactions were successfully retrieved </td><td>  -  </td></tr>
         </table>
         */
        public okhttp3.Call buildCall(final ApiCallback _callback) throws ApiException {
            return getAllCustomerTransactionsCall(customerId, fromDate, toDate, start, limit, sort, includePending, _callback);
        }


        /**
         * Execute getAllCustomerTransactions request
         * @return Transactions
         * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
         * @http.response.details
         <table summary="Response Details" border="1">
            <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
            <tr><td> 200 </td><td> The transactions were successfully retrieved </td><td>  -  </td></tr>
         </table>
         */
        public Transactions execute() throws ApiException {
            ApiResponse<Transactions> localVarResp = getAllCustomerTransactionsWithHttpInfo(customerId, fromDate, toDate, start, limit, sort, includePending);
            return localVarResp.getResponseBody();
        }

        /**
         * Execute getAllCustomerTransactions request with HTTP info returned
         * @return ApiResponse&lt;Transactions&gt;
         * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
         * @http.response.details
         <table summary="Response Details" border="1">
            <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
            <tr><td> 200 </td><td> The transactions were successfully retrieved </td><td>  -  </td></tr>
         </table>
         */
        public ApiResponse<Transactions> executeWithHttpInfo() throws ApiException {
            return getAllCustomerTransactionsWithHttpInfo(customerId, fromDate, toDate, start, limit, sort, includePending);
        }

        /**
         * Execute getAllCustomerTransactions request (asynchronously)
         * @param _callback The callback to be executed when the API call finishes
         * @return The request call
         * @throws ApiException If fail to process the API call, e.g. serializing the request body object
         * @http.response.details
         <table summary="Response Details" border="1">
            <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
            <tr><td> 200 </td><td> The transactions were successfully retrieved </td><td>  -  </td></tr>
         </table>
         */
        public okhttp3.Call executeAsync(final ApiCallback<Transactions> _callback) throws ApiException {
            return getAllCustomerTransactionsAsync(customerId, fromDate, toDate, start, limit, sort, includePending, _callback);
        }
    }

    /**
     * Get All Customer Transactions
     * Get all transactions available for this customer within the given date range, across all accounts. This service supports paging and sorting by &#x60;transactionDate&#x60; (or &#x60;postedDate&#x60; if no transaction date is provided), with a maximum of 1000 transactions per request.  Standard consumer aggregation provides up to 180 days of transactions prior to the date each account was added to the Finicity system. To access older transactions, you must first call the service Load Historic Transactions for Account.  There is no limit for the size of the window between &#x60;fromDate&#x60; and &#x60;toDate&#x60;, however, the maximum number of transactions returned on one page is 1000.  _Supported regions_: ![🇺🇸](https://flagcdn.com/20x15/us.png)
     * @param customerId A customer ID (required)
     * @param fromDate A start date (required)
     * @param toDate A end date (required)
     * @return GetAllCustomerTransactionsRequestBuilder
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> The transactions were successfully retrieved </td><td>  -  </td></tr>
     </table>
     */
    public GetAllCustomerTransactionsRequestBuilder getAllCustomerTransactions(String customerId, Long fromDate, Long toDate) throws IllegalArgumentException {
        if (customerId == null) throw new IllegalArgumentException("\"customerId\" is required but got null");
            

        if (fromDate == null) throw new IllegalArgumentException("\"fromDate\" is required but got null");
        if (toDate == null) throw new IllegalArgumentException("\"toDate\" is required but got null");
        return new GetAllCustomerTransactionsRequestBuilder(customerId, fromDate, toDate);
    }
    private okhttp3.Call getByIdCall(String customerId, Long transactionId, final ApiCallback _callback) throws ApiException {
        String basePath = null;
        // Operation Servers
        String[] localBasePaths = new String[] {  };

        // Determine Base Path to Use
        if (localCustomBaseUrl != null){
            basePath = localCustomBaseUrl;
        } else if ( localBasePaths.length > 0 ) {
            basePath = localBasePaths[localHostIndex];
        } else {
            basePath = null;
        }

        Object localVarPostBody = null;

        // create path and map variables
        String localVarPath = "/aggregation/v2/customers/{customerId}/transactions/{transactionId}"
            .replace("{" + "customerId" + "}", localVarApiClient.escapeString(customerId.toString()))
            .replace("{" + "transactionId" + "}", localVarApiClient.escapeString(transactionId.toString()));

        List<Pair> localVarQueryParams = new ArrayList<Pair>();
        List<Pair> localVarCollectionQueryParams = new ArrayList<Pair>();
        Map<String, String> localVarHeaderParams = new HashMap<String, String>();
        Map<String, String> localVarCookieParams = new HashMap<String, String>();
        Map<String, Object> localVarFormParams = new HashMap<String, Object>();

        final String[] localVarAccepts = {
            "application/json"
        };
        final String localVarAccept = localVarApiClient.selectHeaderAccept(localVarAccepts);
        if (localVarAccept != null) {
            localVarHeaderParams.put("Accept", localVarAccept);
        }

        final String[] localVarContentTypes = {
        };
        final String localVarContentType = localVarApiClient.selectHeaderContentType(localVarContentTypes);
        if (localVarContentType != null) {
            localVarHeaderParams.put("Content-Type", localVarContentType);
        }

        String[] localVarAuthNames = new String[] { "FinicityAppKey", "FinicityAppToken" };
        return localVarApiClient.buildCall(basePath, localVarPath, "GET", localVarQueryParams, localVarCollectionQueryParams, localVarPostBody, localVarHeaderParams, localVarCookieParams, localVarFormParams, localVarAuthNames, _callback);
    }

    @SuppressWarnings("rawtypes")
    private okhttp3.Call getByIdValidateBeforeCall(String customerId, Long transactionId, final ApiCallback _callback) throws ApiException {
        // verify the required parameter 'customerId' is set
        if (customerId == null) {
            throw new ApiException("Missing the required parameter 'customerId' when calling getById(Async)");
        }

        // verify the required parameter 'transactionId' is set
        if (transactionId == null) {
            throw new ApiException("Missing the required parameter 'transactionId' when calling getById(Async)");
        }

        return getByIdCall(customerId, transactionId, _callback);

    }


    private ApiResponse<Transaction> getByIdWithHttpInfo(String customerId, Long transactionId) throws ApiException {
        okhttp3.Call localVarCall = getByIdValidateBeforeCall(customerId, transactionId, null);
        Type localVarReturnType = new TypeToken<Transaction>(){}.getType();
        return localVarApiClient.execute(localVarCall, localVarReturnType);
    }

    private okhttp3.Call getByIdAsync(String customerId, Long transactionId, final ApiCallback<Transaction> _callback) throws ApiException {

        okhttp3.Call localVarCall = getByIdValidateBeforeCall(customerId, transactionId, _callback);
        Type localVarReturnType = new TypeToken<Transaction>(){}.getType();
        localVarApiClient.executeAsync(localVarCall, localVarReturnType, _callback);
        return localVarCall;
    }

    public class GetByIdRequestBuilder {
        private final String customerId;
        private final Long transactionId;

        private GetByIdRequestBuilder(String customerId, Long transactionId) {
            this.customerId = customerId;
            this.transactionId = transactionId;
        }

        /**
         * Build call for getById
         * @param _callback ApiCallback API callback
         * @return Call to execute
         * @throws ApiException If fail to serialize the request body object
         * @http.response.details
         <table summary="Response Details" border="1">
            <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
            <tr><td> 200 </td><td> The transaction was successfully retrieved </td><td>  -  </td></tr>
         </table>
         */
        public okhttp3.Call buildCall(final ApiCallback _callback) throws ApiException {
            return getByIdCall(customerId, transactionId, _callback);
        }


        /**
         * Execute getById request
         * @return Transaction
         * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
         * @http.response.details
         <table summary="Response Details" border="1">
            <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
            <tr><td> 200 </td><td> The transaction was successfully retrieved </td><td>  -  </td></tr>
         </table>
         */
        public Transaction execute() throws ApiException {
            ApiResponse<Transaction> localVarResp = getByIdWithHttpInfo(customerId, transactionId);
            return localVarResp.getResponseBody();
        }

        /**
         * Execute getById request with HTTP info returned
         * @return ApiResponse&lt;Transaction&gt;
         * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
         * @http.response.details
         <table summary="Response Details" border="1">
            <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
            <tr><td> 200 </td><td> The transaction was successfully retrieved </td><td>  -  </td></tr>
         </table>
         */
        public ApiResponse<Transaction> executeWithHttpInfo() throws ApiException {
            return getByIdWithHttpInfo(customerId, transactionId);
        }

        /**
         * Execute getById request (asynchronously)
         * @param _callback The callback to be executed when the API call finishes
         * @return The request call
         * @throws ApiException If fail to process the API call, e.g. serializing the request body object
         * @http.response.details
         <table summary="Response Details" border="1">
            <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
            <tr><td> 200 </td><td> The transaction was successfully retrieved </td><td>  -  </td></tr>
         </table>
         */
        public okhttp3.Call executeAsync(final ApiCallback<Transaction> _callback) throws ApiException {
            return getByIdAsync(customerId, transactionId, _callback);
        }
    }

    /**
     * Get Customer Transaction by ID
     * Get details for the given transaction.  _Supported regions_: ![🇺🇸](https://flagcdn.com/20x15/us.png)
     * @param customerId A customer ID (required)
     * @param transactionId A transaction ID (required)
     * @return GetByIdRequestBuilder
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> The transaction was successfully retrieved </td><td>  -  </td></tr>
     </table>
     */
    public GetByIdRequestBuilder getById(String customerId, Long transactionId) throws IllegalArgumentException {
        if (customerId == null) throw new IllegalArgumentException("\"customerId\" is required but got null");
            

        if (transactionId == null) throw new IllegalArgumentException("\"transactionId\" is required but got null");
        return new GetByIdRequestBuilder(customerId, transactionId);
    }
    private okhttp3.Call getCustomerAccountTransactionsCall(String customerId, String accountId, Long fromDate, Long toDate, Integer start, Integer limit, String sort, Boolean includePending, final ApiCallback _callback) throws ApiException {
        String basePath = null;
        // Operation Servers
        String[] localBasePaths = new String[] {  };

        // Determine Base Path to Use
        if (localCustomBaseUrl != null){
            basePath = localCustomBaseUrl;
        } else if ( localBasePaths.length > 0 ) {
            basePath = localBasePaths[localHostIndex];
        } else {
            basePath = null;
        }

        Object localVarPostBody = null;

        // create path and map variables
        String localVarPath = "/aggregation/v4/customers/{customerId}/accounts/{accountId}/transactions"
            .replace("{" + "customerId" + "}", localVarApiClient.escapeString(customerId.toString()))
            .replace("{" + "accountId" + "}", localVarApiClient.escapeString(accountId.toString()));

        List<Pair> localVarQueryParams = new ArrayList<Pair>();
        List<Pair> localVarCollectionQueryParams = new ArrayList<Pair>();
        Map<String, String> localVarHeaderParams = new HashMap<String, String>();
        Map<String, String> localVarCookieParams = new HashMap<String, String>();
        Map<String, Object> localVarFormParams = new HashMap<String, Object>();

        if (fromDate != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("fromDate", fromDate));
        }

        if (toDate != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("toDate", toDate));
        }

        if (start != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("start", start));
        }

        if (limit != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("limit", limit));
        }

        if (sort != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("sort", sort));
        }

        if (includePending != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("includePending", includePending));
        }

        final String[] localVarAccepts = {
            "application/json"
        };
        final String localVarAccept = localVarApiClient.selectHeaderAccept(localVarAccepts);
        if (localVarAccept != null) {
            localVarHeaderParams.put("Accept", localVarAccept);
        }

        final String[] localVarContentTypes = {
        };
        final String localVarContentType = localVarApiClient.selectHeaderContentType(localVarContentTypes);
        if (localVarContentType != null) {
            localVarHeaderParams.put("Content-Type", localVarContentType);
        }

        String[] localVarAuthNames = new String[] { "FinicityAppKey", "FinicityAppToken" };
        return localVarApiClient.buildCall(basePath, localVarPath, "GET", localVarQueryParams, localVarCollectionQueryParams, localVarPostBody, localVarHeaderParams, localVarCookieParams, localVarFormParams, localVarAuthNames, _callback);
    }

    @SuppressWarnings("rawtypes")
    private okhttp3.Call getCustomerAccountTransactionsValidateBeforeCall(String customerId, String accountId, Long fromDate, Long toDate, Integer start, Integer limit, String sort, Boolean includePending, final ApiCallback _callback) throws ApiException {
        // verify the required parameter 'customerId' is set
        if (customerId == null) {
            throw new ApiException("Missing the required parameter 'customerId' when calling getCustomerAccountTransactions(Async)");
        }

        // verify the required parameter 'accountId' is set
        if (accountId == null) {
            throw new ApiException("Missing the required parameter 'accountId' when calling getCustomerAccountTransactions(Async)");
        }

        // verify the required parameter 'fromDate' is set
        if (fromDate == null) {
            throw new ApiException("Missing the required parameter 'fromDate' when calling getCustomerAccountTransactions(Async)");
        }

        // verify the required parameter 'toDate' is set
        if (toDate == null) {
            throw new ApiException("Missing the required parameter 'toDate' when calling getCustomerAccountTransactions(Async)");
        }

        return getCustomerAccountTransactionsCall(customerId, accountId, fromDate, toDate, start, limit, sort, includePending, _callback);

    }


    private ApiResponse<Transactions> getCustomerAccountTransactionsWithHttpInfo(String customerId, String accountId, Long fromDate, Long toDate, Integer start, Integer limit, String sort, Boolean includePending) throws ApiException {
        okhttp3.Call localVarCall = getCustomerAccountTransactionsValidateBeforeCall(customerId, accountId, fromDate, toDate, start, limit, sort, includePending, null);
        Type localVarReturnType = new TypeToken<Transactions>(){}.getType();
        return localVarApiClient.execute(localVarCall, localVarReturnType);
    }

    private okhttp3.Call getCustomerAccountTransactionsAsync(String customerId, String accountId, Long fromDate, Long toDate, Integer start, Integer limit, String sort, Boolean includePending, final ApiCallback<Transactions> _callback) throws ApiException {

        okhttp3.Call localVarCall = getCustomerAccountTransactionsValidateBeforeCall(customerId, accountId, fromDate, toDate, start, limit, sort, includePending, _callback);
        Type localVarReturnType = new TypeToken<Transactions>(){}.getType();
        localVarApiClient.executeAsync(localVarCall, localVarReturnType, _callback);
        return localVarCall;
    }

    public class GetCustomerAccountTransactionsRequestBuilder {
        private final String customerId;
        private final String accountId;
        private final Long fromDate;
        private final Long toDate;
        private Integer start;
        private Integer limit;
        private String sort;
        private Boolean includePending;

        private GetCustomerAccountTransactionsRequestBuilder(String customerId, String accountId, Long fromDate, Long toDate) {
            this.customerId = customerId;
            this.accountId = accountId;
            this.fromDate = fromDate;
            this.toDate = toDate;
        }

        /**
         * Set start
         * @param start Index of the page of results to return (optional, default to 1)
         * @return GetCustomerAccountTransactionsRequestBuilder
         */
        public GetCustomerAccountTransactionsRequestBuilder start(Integer start) {
            this.start = start;
            return this;
        }
        
        /**
         * Set limit
         * @param limit Maximum number of results per page (optional, default to 25)
         * @return GetCustomerAccountTransactionsRequestBuilder
         */
        public GetCustomerAccountTransactionsRequestBuilder limit(Integer limit) {
            this.limit = limit;
            return this;
        }
        
        /**
         * Set sort
         * @param sort Date sort order: \&quot;asc\&quot; for ascending, \&quot;desc\&quot; for descending (optional, default to desc)
         * @return GetCustomerAccountTransactionsRequestBuilder
         */
        public GetCustomerAccountTransactionsRequestBuilder sort(String sort) {
            this.sort = sort;
            return this;
        }
        
        /**
         * Set includePending
         * @param includePending If pending transactions must be included (optional, default to false)
         * @return GetCustomerAccountTransactionsRequestBuilder
         */
        public GetCustomerAccountTransactionsRequestBuilder includePending(Boolean includePending) {
            this.includePending = includePending;
            return this;
        }
        
        /**
         * Build call for getCustomerAccountTransactions
         * @param _callback ApiCallback API callback
         * @return Call to execute
         * @throws ApiException If fail to serialize the request body object
         * @http.response.details
         <table summary="Response Details" border="1">
            <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
            <tr><td> 200 </td><td> The transactions were successfully retrieved </td><td>  -  </td></tr>
         </table>
         */
        public okhttp3.Call buildCall(final ApiCallback _callback) throws ApiException {
            return getCustomerAccountTransactionsCall(customerId, accountId, fromDate, toDate, start, limit, sort, includePending, _callback);
        }


        /**
         * Execute getCustomerAccountTransactions request
         * @return Transactions
         * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
         * @http.response.details
         <table summary="Response Details" border="1">
            <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
            <tr><td> 200 </td><td> The transactions were successfully retrieved </td><td>  -  </td></tr>
         </table>
         */
        public Transactions execute() throws ApiException {
            ApiResponse<Transactions> localVarResp = getCustomerAccountTransactionsWithHttpInfo(customerId, accountId, fromDate, toDate, start, limit, sort, includePending);
            return localVarResp.getResponseBody();
        }

        /**
         * Execute getCustomerAccountTransactions request with HTTP info returned
         * @return ApiResponse&lt;Transactions&gt;
         * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
         * @http.response.details
         <table summary="Response Details" border="1">
            <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
            <tr><td> 200 </td><td> The transactions were successfully retrieved </td><td>  -  </td></tr>
         </table>
         */
        public ApiResponse<Transactions> executeWithHttpInfo() throws ApiException {
            return getCustomerAccountTransactionsWithHttpInfo(customerId, accountId, fromDate, toDate, start, limit, sort, includePending);
        }

        /**
         * Execute getCustomerAccountTransactions request (asynchronously)
         * @param _callback The callback to be executed when the API call finishes
         * @return The request call
         * @throws ApiException If fail to process the API call, e.g. serializing the request body object
         * @http.response.details
         <table summary="Response Details" border="1">
            <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
            <tr><td> 200 </td><td> The transactions were successfully retrieved </td><td>  -  </td></tr>
         </table>
         */
        public okhttp3.Call executeAsync(final ApiCallback<Transactions> _callback) throws ApiException {
            return getCustomerAccountTransactionsAsync(customerId, accountId, fromDate, toDate, start, limit, sort, includePending, _callback);
        }
    }

    /**
     * Get Customer Account Transactions
     * Get all transactions available for this customer account within the given date range. This service supports paging and sorting by &#x60;transactionDate&#x60; (or &#x60;postedDate&#x60; if no transaction date is provided), with a maximum of 1000 transactions per request.  Standard consumer aggregation provides up to 180 days of transactions prior to the date each account was added to the Finicity system. To access older transactions, you must first call the Cash Flow Verification service Load Historic Transactions for Account.  There is no limit for the size of the window between &#x60;fromDate&#x60; and &#x60;toDate&#x60;, however, the maximum number of transactions returned on one page is 1000.  _Supported regions_: ![🇺🇸](https://flagcdn.com/20x15/us.png)
     * @param customerId A customer ID (required)
     * @param accountId The account ID (required)
     * @param fromDate A start date (required)
     * @param toDate A end date (required)
     * @return GetCustomerAccountTransactionsRequestBuilder
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> The transactions were successfully retrieved </td><td>  -  </td></tr>
     </table>
     */
    public GetCustomerAccountTransactionsRequestBuilder getCustomerAccountTransactions(String customerId, String accountId, Long fromDate, Long toDate) throws IllegalArgumentException {
        if (customerId == null) throw new IllegalArgumentException("\"customerId\" is required but got null");
            

        if (accountId == null) throw new IllegalArgumentException("\"accountId\" is required but got null");
            

        if (fromDate == null) throw new IllegalArgumentException("\"fromDate\" is required but got null");
        if (toDate == null) throw new IllegalArgumentException("\"toDate\" is required but got null");
        return new GetCustomerAccountTransactionsRequestBuilder(customerId, accountId, fromDate, toDate);
    }
    private okhttp3.Call loadHistoricTransactionsForCustomerAccountCall(String customerId, String accountId, final ApiCallback _callback) throws ApiException {
        String basePath = null;
        // Operation Servers
        String[] localBasePaths = new String[] {  };

        // Determine Base Path to Use
        if (localCustomBaseUrl != null){
            basePath = localCustomBaseUrl;
        } else if ( localBasePaths.length > 0 ) {
            basePath = localBasePaths[localHostIndex];
        } else {
            basePath = null;
        }

        Object localVarPostBody = null;

        // create path and map variables
        String localVarPath = "/aggregation/v1/customers/{customerId}/accounts/{accountId}/transactions/historic"
            .replace("{" + "customerId" + "}", localVarApiClient.escapeString(customerId.toString()))
            .replace("{" + "accountId" + "}", localVarApiClient.escapeString(accountId.toString()));

        List<Pair> localVarQueryParams = new ArrayList<Pair>();
        List<Pair> localVarCollectionQueryParams = new ArrayList<Pair>();
        Map<String, String> localVarHeaderParams = new HashMap<String, String>();
        Map<String, String> localVarCookieParams = new HashMap<String, String>();
        Map<String, Object> localVarFormParams = new HashMap<String, Object>();

        final String[] localVarAccepts = {
            "application/json"
        };
        final String localVarAccept = localVarApiClient.selectHeaderAccept(localVarAccepts);
        if (localVarAccept != null) {
            localVarHeaderParams.put("Accept", localVarAccept);
        }

        final String[] localVarContentTypes = {
        };
        final String localVarContentType = localVarApiClient.selectHeaderContentType(localVarContentTypes);
        if (localVarContentType != null) {
            localVarHeaderParams.put("Content-Type", localVarContentType);
        }

        String[] localVarAuthNames = new String[] { "FinicityAppKey", "FinicityAppToken" };
        return localVarApiClient.buildCall(basePath, localVarPath, "POST", localVarQueryParams, localVarCollectionQueryParams, localVarPostBody, localVarHeaderParams, localVarCookieParams, localVarFormParams, localVarAuthNames, _callback);
    }

    @SuppressWarnings("rawtypes")
    private okhttp3.Call loadHistoricTransactionsForCustomerAccountValidateBeforeCall(String customerId, String accountId, final ApiCallback _callback) throws ApiException {
        // verify the required parameter 'customerId' is set
        if (customerId == null) {
            throw new ApiException("Missing the required parameter 'customerId' when calling loadHistoricTransactionsForCustomerAccount(Async)");
        }

        // verify the required parameter 'accountId' is set
        if (accountId == null) {
            throw new ApiException("Missing the required parameter 'accountId' when calling loadHistoricTransactionsForCustomerAccount(Async)");
        }

        return loadHistoricTransactionsForCustomerAccountCall(customerId, accountId, _callback);

    }


    private ApiResponse<Void> loadHistoricTransactionsForCustomerAccountWithHttpInfo(String customerId, String accountId) throws ApiException {
        okhttp3.Call localVarCall = loadHistoricTransactionsForCustomerAccountValidateBeforeCall(customerId, accountId, null);
        return localVarApiClient.execute(localVarCall);
    }

    private okhttp3.Call loadHistoricTransactionsForCustomerAccountAsync(String customerId, String accountId, final ApiCallback<Void> _callback) throws ApiException {

        okhttp3.Call localVarCall = loadHistoricTransactionsForCustomerAccountValidateBeforeCall(customerId, accountId, _callback);
        localVarApiClient.executeAsync(localVarCall, _callback);
        return localVarCall;
    }

    public class LoadHistoricTransactionsForCustomerAccountRequestBuilder {
        private final String customerId;
        private final String accountId;

        private LoadHistoricTransactionsForCustomerAccountRequestBuilder(String customerId, String accountId) {
            this.customerId = customerId;
            this.accountId = accountId;
        }

        /**
         * Build call for loadHistoricTransactionsForCustomerAccount
         * @param _callback ApiCallback API callback
         * @return Call to execute
         * @throws ApiException If fail to serialize the request body object
         * @http.response.details
         <table summary="Response Details" border="1">
            <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
            <tr><td> 203 </td><td> The response contains an MFA challenge in XML or JSON format. Contact your Account Manager or Systems Engineers to determine the best route to handle this error. </td><td>  -  </td></tr>
            <tr><td> 204 </td><td> Historic transactions have been loaded successfully. The transactions are now available by calling the Get Customer Account Transactions API. </td><td>  -  </td></tr>
         </table>
         */
        public okhttp3.Call buildCall(final ApiCallback _callback) throws ApiException {
            return loadHistoricTransactionsForCustomerAccountCall(customerId, accountId, _callback);
        }


        /**
         * Execute loadHistoricTransactionsForCustomerAccount request
         * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
         * @http.response.details
         <table summary="Response Details" border="1">
            <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
            <tr><td> 203 </td><td> The response contains an MFA challenge in XML or JSON format. Contact your Account Manager or Systems Engineers to determine the best route to handle this error. </td><td>  -  </td></tr>
            <tr><td> 204 </td><td> Historic transactions have been loaded successfully. The transactions are now available by calling the Get Customer Account Transactions API. </td><td>  -  </td></tr>
         </table>
         */
        public void execute() throws ApiException {
            loadHistoricTransactionsForCustomerAccountWithHttpInfo(customerId, accountId);
        }

        /**
         * Execute loadHistoricTransactionsForCustomerAccount request with HTTP info returned
         * @return ApiResponse&lt;Void&gt;
         * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
         * @http.response.details
         <table summary="Response Details" border="1">
            <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
            <tr><td> 203 </td><td> The response contains an MFA challenge in XML or JSON format. Contact your Account Manager or Systems Engineers to determine the best route to handle this error. </td><td>  -  </td></tr>
            <tr><td> 204 </td><td> Historic transactions have been loaded successfully. The transactions are now available by calling the Get Customer Account Transactions API. </td><td>  -  </td></tr>
         </table>
         */
        public ApiResponse<Void> executeWithHttpInfo() throws ApiException {
            return loadHistoricTransactionsForCustomerAccountWithHttpInfo(customerId, accountId);
        }

        /**
         * Execute loadHistoricTransactionsForCustomerAccount request (asynchronously)
         * @param _callback The callback to be executed when the API call finishes
         * @return The request call
         * @throws ApiException If fail to process the API call, e.g. serializing the request body object
         * @http.response.details
         <table summary="Response Details" border="1">
            <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
            <tr><td> 203 </td><td> The response contains an MFA challenge in XML or JSON format. Contact your Account Manager or Systems Engineers to determine the best route to handle this error. </td><td>  -  </td></tr>
            <tr><td> 204 </td><td> Historic transactions have been loaded successfully. The transactions are now available by calling the Get Customer Account Transactions API. </td><td>  -  </td></tr>
         </table>
         */
        public okhttp3.Call executeAsync(final ApiCallback<Void> _callback) throws ApiException {
            return loadHistoricTransactionsForCustomerAccountAsync(customerId, accountId, _callback);
        }
    }

    /**
     * Load Historic Transactions for Customer Account
     * Connect to the account&#39;s financial institution and load up to 24 months of historic transactions for the account. Length of history varies by institution.  This is a premium service. The billable event is a call to this service specifying a customer ID that has not been seen before by this service. (If this service is called multiple times with the same customer ID, to load transactions from multiple accounts, only one billable event has occurred.)  The recommended timeout setting for this request is 180 seconds in order to receive a response. However, you can terminate the connection after making the call the operation will still complete. You will have to pull the account records to check for an updated aggregation attempt date to know when the refresh is complete.  The date range sent to the institution is calculated from the account&#39;s &#x60;createdDate&#x60;. This means that calling this service a second time for the same account normally will not add any new transactions for the account. For this reason, a second call to this service for a known account ID will usually return immediately.  In a few specific scenarios, it may be desirable to force a second connection to the institution for a known account ID. Some examples are:  * The institution&#39;s policy has changed, making more transactions available * Finicity has now added a longer transaction history support for the institution * The first call encountered an error, and the resulting Aggregation Ticket has now been fixed by the Finicity Support Team  In these cases, the POST request can contain the parameter &#x60;force&#x3D;true&#x60; in the request body to force the second connection.  _Supported regions_: ![🇺🇸](https://flagcdn.com/20x15/us.png)
     * @param customerId A customer ID (required)
     * @param accountId The account ID (required)
     * @return LoadHistoricTransactionsForCustomerAccountRequestBuilder
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 203 </td><td> The response contains an MFA challenge in XML or JSON format. Contact your Account Manager or Systems Engineers to determine the best route to handle this error. </td><td>  -  </td></tr>
        <tr><td> 204 </td><td> Historic transactions have been loaded successfully. The transactions are now available by calling the Get Customer Account Transactions API. </td><td>  -  </td></tr>
     </table>
     */
    public LoadHistoricTransactionsForCustomerAccountRequestBuilder loadHistoricTransactionsForCustomerAccount(String customerId, String accountId) throws IllegalArgumentException {
        if (customerId == null) throw new IllegalArgumentException("\"customerId\" is required but got null");
            

        if (accountId == null) throw new IllegalArgumentException("\"accountId\" is required but got null");
            

        return new LoadHistoricTransactionsForCustomerAccountRequestBuilder(customerId, accountId);
    }
}
